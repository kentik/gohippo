// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tagging.proto

package hippo

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TagBatchPartSender holds metadata about the sender
type TagBatchPartSender struct {
	ServiceName     string `protobuf:"bytes,1,opt,name=ServiceName,proto3" json:"service_name,omitempty"`
	ServiceInstance string `protobuf:"bytes,2,opt,name=ServiceInstance,proto3" json:"service_instance,omitempty"`
	HostName        string `protobuf:"bytes,3,opt,name=HostName,proto3" json:"host_name,omitempty"`
}

func (m *TagBatchPartSender) Reset()      { *m = TagBatchPartSender{} }
func (*TagBatchPartSender) ProtoMessage() {}
func (*TagBatchPartSender) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{0}
}
func (m *TagBatchPartSender) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagBatchPartSender) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagBatchPartSender.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagBatchPartSender) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagBatchPartSender.Merge(m, src)
}
func (m *TagBatchPartSender) XXX_Size() int {
	return m.Size()
}
func (m *TagBatchPartSender) XXX_DiscardUnknown() {
	xxx_messageInfo_TagBatchPartSender.DiscardUnknown(m)
}

var xxx_messageInfo_TagBatchPartSender proto.InternalMessageInfo

func (m *TagBatchPartSender) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *TagBatchPartSender) GetServiceInstance() string {
	if m != nil {
		return m.ServiceInstance
	}
	return ""
}

func (m *TagBatchPartSender) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

// TagBatchPart represents a tag update batch from a customer via Kentik API
type TagBatchPart struct {
	BatchGUID  string      `protobuf:"bytes,2,opt,name=BatchGUID,proto3" json:"guid"`
	ReplaceAll bool        `protobuf:"varint,3,opt,name=ReplaceAll,proto3" json:"replace_all"`
	IsComplete bool        `protobuf:"varint,4,opt,name=IsComplete,proto3" json:"complete"`
	Upserts    []TagUpsert `protobuf:"bytes,5,rep,name=Upserts,proto3" json:"upserts"`
	Deletes    []TagDelete `protobuf:"bytes,6,rep,name=Deletes,proto3" json:"deletes"`
	TTLMinutes uint32      `protobuf:"varint,7,opt,name=TTLMinutes,proto3" json:"ttl_minutes"`
	// TagBatchSender will be logged to help track down who sent a batch
	Sender TagBatchPartSender `protobuf:"bytes,8,opt,name=Sender,proto3" json:"sender"`
}

func (m *TagBatchPart) Reset()      { *m = TagBatchPart{} }
func (*TagBatchPart) ProtoMessage() {}
func (*TagBatchPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{1}
}
func (m *TagBatchPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagBatchPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagBatchPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagBatchPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagBatchPart.Merge(m, src)
}
func (m *TagBatchPart) XXX_Size() int {
	return m.Size()
}
func (m *TagBatchPart) XXX_DiscardUnknown() {
	xxx_messageInfo_TagBatchPart.DiscardUnknown(m)
}

var xxx_messageInfo_TagBatchPart proto.InternalMessageInfo

func (m *TagBatchPart) GetBatchGUID() string {
	if m != nil {
		return m.BatchGUID
	}
	return ""
}

func (m *TagBatchPart) GetReplaceAll() bool {
	if m != nil {
		return m.ReplaceAll
	}
	return false
}

func (m *TagBatchPart) GetIsComplete() bool {
	if m != nil {
		return m.IsComplete
	}
	return false
}

func (m *TagBatchPart) GetUpserts() []TagUpsert {
	if m != nil {
		return m.Upserts
	}
	return nil
}

func (m *TagBatchPart) GetDeletes() []TagDelete {
	if m != nil {
		return m.Deletes
	}
	return nil
}

func (m *TagBatchPart) GetTTLMinutes() uint32 {
	if m != nil {
		return m.TTLMinutes
	}
	return 0
}

func (m *TagBatchPart) GetSender() TagBatchPartSender {
	if m != nil {
		return m.Sender
	}
	return TagBatchPartSender{}
}

// FlexStringCriteria defines how we match a flex column (STR00-STR16)
type FlexStringCriteria struct {
	Action string `protobuf:"bytes,1,opt,name=Action,proto3" json:"action"`
	Value  string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
}

func (m *FlexStringCriteria) Reset()      { *m = FlexStringCriteria{} }
func (*FlexStringCriteria) ProtoMessage() {}
func (*FlexStringCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{2}
}
func (m *FlexStringCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlexStringCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlexStringCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlexStringCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlexStringCriteria.Merge(m, src)
}
func (m *FlexStringCriteria) XXX_Size() int {
	return m.Size()
}
func (m *FlexStringCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_FlexStringCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_FlexStringCriteria proto.InternalMessageInfo

func (m *FlexStringCriteria) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *FlexStringCriteria) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TagCriteria defines the criteria of a tag
type TagCriteria struct {
	Direction            string   `protobuf:"bytes,1,opt,name=Direction,proto3" json:"direction"`
	PortRanges           []string `protobuf:"bytes,2,rep,name=PortRanges,proto3" json:"port,omitempty"`
	Protocols            []uint32 `protobuf:"varint,3,rep,packed,name=Protocols,proto3" json:"protocol,omitempty"`
	ASNRanges            []string `protobuf:"bytes,4,rep,name=ASNRanges,proto3" json:"asn,omitempty"`
	VLanRanges           []string `protobuf:"bytes,5,rep,name=VLanRanges,proto3" json:"vlans,omitempty"`
	LastHopASNNames      []string `protobuf:"bytes,6,rep,name=LastHopASNNames,proto3" json:"lasthop_as_name,omitempty"`
	NextHopASNRanges     []string `protobuf:"bytes,7,rep,name=NextHopASNRanges,proto3" json:"nexthop_asn,omitempty"`
	NextHopASNNames      []string `protobuf:"bytes,8,rep,name=NextHopASNNames,proto3" json:"nexthop_as_name,omitempty"`
	BGPASPaths           []string `protobuf:"bytes,9,rep,name=BGPASPaths,proto3" json:"bgp_aspath,omitempty"`
	BGPCommunities       []string `protobuf:"bytes,10,rep,name=BGPCommunities,proto3" json:"bgp_community,omitempty"`
	TCPFlags             uint32   `protobuf:"varint,11,opt,name=TCPFlags,proto3" json:"tcp_flags,omitempty"`
	IPAddresses          []string `protobuf:"bytes,12,rep,name=IPAddresses,proto3" json:"addr,omitempty"`
	MACAddresses         []string `protobuf:"bytes,13,rep,name=MACAddresses,proto3" json:"mac,omitempty"`
	CountryCodes         []string `protobuf:"bytes,14,rep,name=CountryCodes,proto3" json:"country,omitempty"`
	SiteNameRegexes      []string `protobuf:"bytes,15,rep,name=SiteNameRegexes,proto3" json:"site,omitempty"`
	DeviceTypeRegexes    []string `protobuf:"bytes,16,rep,name=DeviceTypeRegexes,proto3" json:"device_type,omitempty"`
	InterfaceNameRegexes []string `protobuf:"bytes,17,rep,name=InterfaceNameRegexes,proto3" json:"interface_name,omitempty"`
	DeviceNameRegexes    []string `protobuf:"bytes,18,rep,name=DeviceNameRegexes,proto3" json:"device_name,omitempty"`
	NextHopIPAddresses   []string `protobuf:"bytes,19,rep,name=NextHopIPAddresses,proto3" json:"nexthop,omitempty"`
	// flexible flow columns: strings
	Str00 []FlexStringCriteria `protobuf:"bytes,20,rep,name=Str00,proto3" json:"str00,omitempty"`
	Str01 []FlexStringCriteria `protobuf:"bytes,21,rep,name=Str01,proto3" json:"str01,omitempty"`
	Str02 []FlexStringCriteria `protobuf:"bytes,22,rep,name=Str02,proto3" json:"str02,omitempty"`
	Str03 []FlexStringCriteria `protobuf:"bytes,23,rep,name=Str03,proto3" json:"str03,omitempty"`
	Str04 []FlexStringCriteria `protobuf:"bytes,24,rep,name=Str04,proto3" json:"str04,omitempty"`
	Str05 []FlexStringCriteria `protobuf:"bytes,25,rep,name=Str05,proto3" json:"str05,omitempty"`
	Str06 []FlexStringCriteria `protobuf:"bytes,26,rep,name=Str06,proto3" json:"str06,omitempty"`
	Str07 []FlexStringCriteria `protobuf:"bytes,27,rep,name=Str07,proto3" json:"str07,omitempty"`
	Str08 []FlexStringCriteria `protobuf:"bytes,28,rep,name=Str08,proto3" json:"str08,omitempty"`
	Str09 []FlexStringCriteria `protobuf:"bytes,29,rep,name=Str09,proto3" json:"str09,omitempty"`
	Str10 []FlexStringCriteria `protobuf:"bytes,30,rep,name=Str10,proto3" json:"str10,omitempty"`
	Str11 []FlexStringCriteria `protobuf:"bytes,31,rep,name=Str11,proto3" json:"str11,omitempty"`
	Str12 []FlexStringCriteria `protobuf:"bytes,32,rep,name=Str12,proto3" json:"str12,omitempty"`
	Str13 []FlexStringCriteria `protobuf:"bytes,33,rep,name=Str13,proto3" json:"str13,omitempty"`
	Str14 []FlexStringCriteria `protobuf:"bytes,34,rep,name=Str14,proto3" json:"str14,omitempty"`
	Str15 []FlexStringCriteria `protobuf:"bytes,35,rep,name=Str15,proto3" json:"str15,omitempty"`
	Str16 []FlexStringCriteria `protobuf:"bytes,36,rep,name=Str16,proto3" json:"str16,omitempty"`
	// flexible flow columns: uint64s
	Int6400 []string `protobuf:"bytes,37,rep,name=Int6400,proto3" json:"int64_00,omitempty"`
	Int6401 []string `protobuf:"bytes,38,rep,name=Int6401,proto3" json:"int64_01,omitempty"`
	Int6402 []string `protobuf:"bytes,39,rep,name=Int6402,proto3" json:"int64_02,omitempty"`
	Int6403 []string `protobuf:"bytes,40,rep,name=Int6403,proto3" json:"int64_03,omitempty"`
	Int6404 []string `protobuf:"bytes,41,rep,name=Int6404,proto3" json:"int64_04,omitempty"`
	// flexible flow columns: app_protocol
	AppProtocol []string `protobuf:"bytes,42,rep,name=AppProtocol,proto3" json:"app_protocol,omitempty"`
	// flexible flow columns: uint32s
	Int00 []string `protobuf:"bytes,43,rep,name=Int00,proto3" json:"int00,omitempty"`
	Int01 []string `protobuf:"bytes,44,rep,name=Int01,proto3" json:"int01,omitempty"`
	Int02 []string `protobuf:"bytes,45,rep,name=Int02,proto3" json:"int02,omitempty"`
	Int03 []string `protobuf:"bytes,46,rep,name=Int03,proto3" json:"int03,omitempty"`
	Int04 []string `protobuf:"bytes,47,rep,name=Int04,proto3" json:"int04,omitempty"`
	Int05 []string `protobuf:"bytes,48,rep,name=Int05,proto3" json:"int05,omitempty"`
	// flexible flow columns: IP addresses
	Inet00 []string `protobuf:"bytes,49,rep,name=Inet00,proto3" json:"inet_00,omitempty"`
	Inet01 []string `protobuf:"bytes,50,rep,name=Inet01,proto3" json:"inet_01,omitempty"`
	Inet02 []string `protobuf:"bytes,51,rep,name=Inet02,proto3" json:"inet_02,omitempty"`
	Inet03 []string `protobuf:"bytes,52,rep,name=Inet03,proto3" json:"inet_03,omitempty"`
	Inet04 []string `protobuf:"bytes,53,rep,name=Inet04,proto3" json:"inet_04,omitempty"`
}

func (m *TagCriteria) Reset()      { *m = TagCriteria{} }
func (*TagCriteria) ProtoMessage() {}
func (*TagCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{3}
}
func (m *TagCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagCriteria.Merge(m, src)
}
func (m *TagCriteria) XXX_Size() int {
	return m.Size()
}
func (m *TagCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_TagCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_TagCriteria proto.InternalMessageInfo

func (m *TagCriteria) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *TagCriteria) GetPortRanges() []string {
	if m != nil {
		return m.PortRanges
	}
	return nil
}

func (m *TagCriteria) GetProtocols() []uint32 {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *TagCriteria) GetASNRanges() []string {
	if m != nil {
		return m.ASNRanges
	}
	return nil
}

func (m *TagCriteria) GetVLanRanges() []string {
	if m != nil {
		return m.VLanRanges
	}
	return nil
}

func (m *TagCriteria) GetLastHopASNNames() []string {
	if m != nil {
		return m.LastHopASNNames
	}
	return nil
}

func (m *TagCriteria) GetNextHopASNRanges() []string {
	if m != nil {
		return m.NextHopASNRanges
	}
	return nil
}

func (m *TagCriteria) GetNextHopASNNames() []string {
	if m != nil {
		return m.NextHopASNNames
	}
	return nil
}

func (m *TagCriteria) GetBGPASPaths() []string {
	if m != nil {
		return m.BGPASPaths
	}
	return nil
}

func (m *TagCriteria) GetBGPCommunities() []string {
	if m != nil {
		return m.BGPCommunities
	}
	return nil
}

func (m *TagCriteria) GetTCPFlags() uint32 {
	if m != nil {
		return m.TCPFlags
	}
	return 0
}

func (m *TagCriteria) GetIPAddresses() []string {
	if m != nil {
		return m.IPAddresses
	}
	return nil
}

func (m *TagCriteria) GetMACAddresses() []string {
	if m != nil {
		return m.MACAddresses
	}
	return nil
}

func (m *TagCriteria) GetCountryCodes() []string {
	if m != nil {
		return m.CountryCodes
	}
	return nil
}

func (m *TagCriteria) GetSiteNameRegexes() []string {
	if m != nil {
		return m.SiteNameRegexes
	}
	return nil
}

func (m *TagCriteria) GetDeviceTypeRegexes() []string {
	if m != nil {
		return m.DeviceTypeRegexes
	}
	return nil
}

func (m *TagCriteria) GetInterfaceNameRegexes() []string {
	if m != nil {
		return m.InterfaceNameRegexes
	}
	return nil
}

func (m *TagCriteria) GetDeviceNameRegexes() []string {
	if m != nil {
		return m.DeviceNameRegexes
	}
	return nil
}

func (m *TagCriteria) GetNextHopIPAddresses() []string {
	if m != nil {
		return m.NextHopIPAddresses
	}
	return nil
}

func (m *TagCriteria) GetStr00() []FlexStringCriteria {
	if m != nil {
		return m.Str00
	}
	return nil
}

func (m *TagCriteria) GetStr01() []FlexStringCriteria {
	if m != nil {
		return m.Str01
	}
	return nil
}

func (m *TagCriteria) GetStr02() []FlexStringCriteria {
	if m != nil {
		return m.Str02
	}
	return nil
}

func (m *TagCriteria) GetStr03() []FlexStringCriteria {
	if m != nil {
		return m.Str03
	}
	return nil
}

func (m *TagCriteria) GetStr04() []FlexStringCriteria {
	if m != nil {
		return m.Str04
	}
	return nil
}

func (m *TagCriteria) GetStr05() []FlexStringCriteria {
	if m != nil {
		return m.Str05
	}
	return nil
}

func (m *TagCriteria) GetStr06() []FlexStringCriteria {
	if m != nil {
		return m.Str06
	}
	return nil
}

func (m *TagCriteria) GetStr07() []FlexStringCriteria {
	if m != nil {
		return m.Str07
	}
	return nil
}

func (m *TagCriteria) GetStr08() []FlexStringCriteria {
	if m != nil {
		return m.Str08
	}
	return nil
}

func (m *TagCriteria) GetStr09() []FlexStringCriteria {
	if m != nil {
		return m.Str09
	}
	return nil
}

func (m *TagCriteria) GetStr10() []FlexStringCriteria {
	if m != nil {
		return m.Str10
	}
	return nil
}

func (m *TagCriteria) GetStr11() []FlexStringCriteria {
	if m != nil {
		return m.Str11
	}
	return nil
}

func (m *TagCriteria) GetStr12() []FlexStringCriteria {
	if m != nil {
		return m.Str12
	}
	return nil
}

func (m *TagCriteria) GetStr13() []FlexStringCriteria {
	if m != nil {
		return m.Str13
	}
	return nil
}

func (m *TagCriteria) GetStr14() []FlexStringCriteria {
	if m != nil {
		return m.Str14
	}
	return nil
}

func (m *TagCriteria) GetStr15() []FlexStringCriteria {
	if m != nil {
		return m.Str15
	}
	return nil
}

func (m *TagCriteria) GetStr16() []FlexStringCriteria {
	if m != nil {
		return m.Str16
	}
	return nil
}

func (m *TagCriteria) GetInt6400() []string {
	if m != nil {
		return m.Int6400
	}
	return nil
}

func (m *TagCriteria) GetInt6401() []string {
	if m != nil {
		return m.Int6401
	}
	return nil
}

func (m *TagCriteria) GetInt6402() []string {
	if m != nil {
		return m.Int6402
	}
	return nil
}

func (m *TagCriteria) GetInt6403() []string {
	if m != nil {
		return m.Int6403
	}
	return nil
}

func (m *TagCriteria) GetInt6404() []string {
	if m != nil {
		return m.Int6404
	}
	return nil
}

func (m *TagCriteria) GetAppProtocol() []string {
	if m != nil {
		return m.AppProtocol
	}
	return nil
}

func (m *TagCriteria) GetInt00() []string {
	if m != nil {
		return m.Int00
	}
	return nil
}

func (m *TagCriteria) GetInt01() []string {
	if m != nil {
		return m.Int01
	}
	return nil
}

func (m *TagCriteria) GetInt02() []string {
	if m != nil {
		return m.Int02
	}
	return nil
}

func (m *TagCriteria) GetInt03() []string {
	if m != nil {
		return m.Int03
	}
	return nil
}

func (m *TagCriteria) GetInt04() []string {
	if m != nil {
		return m.Int04
	}
	return nil
}

func (m *TagCriteria) GetInt05() []string {
	if m != nil {
		return m.Int05
	}
	return nil
}

func (m *TagCriteria) GetInet00() []string {
	if m != nil {
		return m.Inet00
	}
	return nil
}

func (m *TagCriteria) GetInet01() []string {
	if m != nil {
		return m.Inet01
	}
	return nil
}

func (m *TagCriteria) GetInet02() []string {
	if m != nil {
		return m.Inet02
	}
	return nil
}

func (m *TagCriteria) GetInet03() []string {
	if m != nil {
		return m.Inet03
	}
	return nil
}

func (m *TagCriteria) GetInet04() []string {
	if m != nil {
		return m.Inet04
	}
	return nil
}

// TagUpsert represents a tag or set of populators that have been created or updated
type TagUpsert struct {
	Value    string        `protobuf:"bytes,1,opt,name=Value,proto3" json:"value"`
	Criteria []TagCriteria `protobuf:"bytes,2,rep,name=Criteria,proto3" json:"criteria"`
}

func (m *TagUpsert) Reset()      { *m = TagUpsert{} }
func (*TagUpsert) ProtoMessage() {}
func (*TagUpsert) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{4}
}
func (m *TagUpsert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagUpsert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagUpsert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagUpsert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagUpsert.Merge(m, src)
}
func (m *TagUpsert) XXX_Size() int {
	return m.Size()
}
func (m *TagUpsert) XXX_DiscardUnknown() {
	xxx_messageInfo_TagUpsert.DiscardUnknown(m)
}

var xxx_messageInfo_TagUpsert proto.InternalMessageInfo

func (m *TagUpsert) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *TagUpsert) GetCriteria() []TagCriteria {
	if m != nil {
		return m.Criteria
	}
	return nil
}

// TagDelete represents a tag or populator that's been deleted
type TagDelete struct {
	Value string `protobuf:"bytes,1,opt,name=Value,proto3" json:"value"`
}

func (m *TagDelete) Reset()      { *m = TagDelete{} }
func (*TagDelete) ProtoMessage() {}
func (*TagDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{5}
}
func (m *TagDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagDelete.Merge(m, src)
}
func (m *TagDelete) XXX_Size() int {
	return m.Size()
}
func (m *TagDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_TagDelete.DiscardUnknown(m)
}

var xxx_messageInfo_TagDelete proto.InternalMessageInfo

func (m *TagDelete) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// ASNRange represents a range of ASN numbers
type ASNRange struct {
	Start uint32 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *ASNRange) Reset()      { *m = ASNRange{} }
func (*ASNRange) ProtoMessage() {}
func (*ASNRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{6}
}
func (m *ASNRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ASNRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ASNRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ASNRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASNRange.Merge(m, src)
}
func (m *ASNRange) XXX_Size() int {
	return m.Size()
}
func (m *ASNRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ASNRange.DiscardUnknown(m)
}

var xxx_messageInfo_ASNRange proto.InternalMessageInfo

func (m *ASNRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ASNRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// VLanRange represents a range of VLAN numbers
type VLanRange struct {
	Start uint32 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *VLanRange) Reset()      { *m = VLanRange{} }
func (*VLanRange) ProtoMessage() {}
func (*VLanRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{7}
}
func (m *VLanRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VLanRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VLanRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VLanRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VLanRange.Merge(m, src)
}
func (m *VLanRange) XXX_Size() int {
	return m.Size()
}
func (m *VLanRange) XXX_DiscardUnknown() {
	xxx_messageInfo_VLanRange.DiscardUnknown(m)
}

var xxx_messageInfo_VLanRange proto.InternalMessageInfo

func (m *VLanRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *VLanRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// PortRange represents a range of ports
type PortRange struct {
	Start uint32 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *PortRange) Reset()      { *m = PortRange{} }
func (*PortRange) ProtoMessage() {}
func (*PortRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{8}
}
func (m *PortRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortRange.Merge(m, src)
}
func (m *PortRange) XXX_Size() int {
	return m.Size()
}
func (m *PortRange) XXX_DiscardUnknown() {
	xxx_messageInfo_PortRange.DiscardUnknown(m)
}

var xxx_messageInfo_PortRange proto.InternalMessageInfo

func (m *PortRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *PortRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// FlexUint32Range represents a uint64 range flex column (INT00-INT05)
type FlexUint32Range struct {
	Start uint32 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *FlexUint32Range) Reset()      { *m = FlexUint32Range{} }
func (*FlexUint32Range) ProtoMessage() {}
func (*FlexUint32Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{9}
}
func (m *FlexUint32Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlexUint32Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlexUint32Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlexUint32Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlexUint32Range.Merge(m, src)
}
func (m *FlexUint32Range) XXX_Size() int {
	return m.Size()
}
func (m *FlexUint32Range) XXX_DiscardUnknown() {
	xxx_messageInfo_FlexUint32Range.DiscardUnknown(m)
}

var xxx_messageInfo_FlexUint32Range proto.InternalMessageInfo

func (m *FlexUint32Range) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FlexUint32Range) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

// FlexUint64Range represents a uint64 range flex column (INT64_00-INT64_04)
type FlexUint64Range struct {
	Start uint64 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	End   uint64 `protobuf:"varint,2,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *FlexUint64Range) Reset()      { *m = FlexUint64Range{} }
func (*FlexUint64Range) ProtoMessage() {}
func (*FlexUint64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{10}
}
func (m *FlexUint64Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlexUint64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlexUint64Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlexUint64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlexUint64Range.Merge(m, src)
}
func (m *FlexUint64Range) XXX_Size() int {
	return m.Size()
}
func (m *FlexUint64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_FlexUint64Range.DiscardUnknown(m)
}

var xxx_messageInfo_FlexUint64Range proto.InternalMessageInfo

func (m *FlexUint64Range) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FlexUint64Range) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

// APIServerResponse is the response from the server
type APIServerResponse struct {
	GUID    string `protobuf:"bytes,1,opt,name=GUID,proto3" json:"guid,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"message,omitempty"`
	Error   string `protobuf:"bytes,3,opt,name=Error,proto3" json:"error,omitempty"`
}

func (m *APIServerResponse) Reset()      { *m = APIServerResponse{} }
func (*APIServerResponse) ProtoMessage() {}
func (*APIServerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6398c1b1d4769419, []int{11}
}
func (m *APIServerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APIServerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_APIServerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *APIServerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APIServerResponse.Merge(m, src)
}
func (m *APIServerResponse) XXX_Size() int {
	return m.Size()
}
func (m *APIServerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_APIServerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_APIServerResponse proto.InternalMessageInfo

func (m *APIServerResponse) GetGUID() string {
	if m != nil {
		return m.GUID
	}
	return ""
}

func (m *APIServerResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *APIServerResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*TagBatchPartSender)(nil), "hippo.TagBatchPartSender")
	proto.RegisterType((*TagBatchPart)(nil), "hippo.TagBatchPart")
	proto.RegisterType((*FlexStringCriteria)(nil), "hippo.FlexStringCriteria")
	proto.RegisterType((*TagCriteria)(nil), "hippo.TagCriteria")
	proto.RegisterType((*TagUpsert)(nil), "hippo.TagUpsert")
	proto.RegisterType((*TagDelete)(nil), "hippo.TagDelete")
	proto.RegisterType((*ASNRange)(nil), "hippo.ASNRange")
	proto.RegisterType((*VLanRange)(nil), "hippo.VLanRange")
	proto.RegisterType((*PortRange)(nil), "hippo.PortRange")
	proto.RegisterType((*FlexUint32Range)(nil), "hippo.FlexUint32Range")
	proto.RegisterType((*FlexUint64Range)(nil), "hippo.FlexUint64Range")
	proto.RegisterType((*APIServerResponse)(nil), "hippo.APIServerResponse")
}

func init() { proto.RegisterFile("tagging.proto", fileDescriptor_6398c1b1d4769419) }

var fileDescriptor_6398c1b1d4769419 = []byte{
	// 1586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x98, 0x4f, 0x53, 0xdb, 0xcc,
	0x1d, 0xc7, 0x71, 0x30, 0x60, 0xaf, 0x31, 0x86, 0x0d, 0x09, 0x0b, 0xcf, 0x13, 0x8b, 0xba, 0x6d,
	0x4a, 0x1a, 0x02, 0xd6, 0x1f, 0x13, 0x98, 0xe4, 0x50, 0xdb, 0x10, 0x70, 0x27, 0x61, 0x3c, 0x32,
	0x64, 0xa6, 0xbd, 0x78, 0x14, 0x7b, 0x23, 0x34, 0xb1, 0x25, 0x8d, 0xb4, 0x66, 0xe0, 0xd6, 0x6b,
	0x6f, 0xbd, 0xf5, 0x2d, 0xf4, 0x1d, 0xf4, 0x2d, 0xe4, 0x98, 0xde, 0x72, 0xd2, 0x34, 0xe4, 0xd2,
	0xd1, 0x29, 0x2f, 0xa1, 0xa3, 0x95, 0xd6, 0x92, 0x57, 0xcc, 0xb4, 0x7a, 0x2e, 0x19, 0xf4, 0xdb,
	0xef, 0xf7, 0xa3, 0x9f, 0xe5, 0xef, 0xfe, 0xa2, 0x35, 0x28, 0x13, 0x4d, 0xd7, 0x0d, 0x53, 0xdf,
	0xb3, 0x1d, 0x8b, 0x58, 0x70, 0xe1, 0xca, 0xb0, 0x6d, 0x6b, 0x6b, 0x5d, 0xb7, 0x74, 0x8b, 0x56,
	0xf6, 0x83, 0xbf, 0xc2, 0xc5, 0xda, 0xbf, 0x72, 0x00, 0x5e, 0x68, 0x7a, 0x4b, 0x23, 0x83, 0xab,
	0xae, 0xe6, 0x90, 0x1e, 0x36, 0x87, 0xd8, 0x81, 0xaf, 0x41, 0xa9, 0x87, 0x9d, 0x6b, 0x63, 0x80,
	0xcf, 0xb5, 0x31, 0x46, 0xb9, 0xed, 0xdc, 0x4e, 0xb1, 0xb5, 0xe5, 0x7b, 0xc2, 0x63, 0x37, 0x2c,
	0xf7, 0x4d, 0x6d, 0x8c, 0x77, 0xad, 0xb1, 0x41, 0xf0, 0xd8, 0x26, 0xb7, 0x6a, 0x52, 0x0e, 0xcf,
	0x40, 0x25, 0xba, 0xec, 0x98, 0x2e, 0xd1, 0xcc, 0x01, 0x46, 0x0f, 0x28, 0xa1, 0xea, 0x7b, 0xc2,
	0x16, 0x23, 0x18, 0xd1, 0x5a, 0x82, 0xc2, 0xdb, 0xa0, 0x0c, 0x0a, 0x67, 0x96, 0x4b, 0x68, 0x13,
	0xf3, 0x14, 0xb1, 0xe1, 0x7b, 0xc2, 0xc3, 0x2b, 0xcb, 0x25, 0x7c, 0x07, 0x53, 0x61, 0xed, 0xaf,
	0xf3, 0x60, 0x39, 0xf9, 0x99, 0xe0, 0x53, 0x50, 0xa4, 0x17, 0xa7, 0x97, 0x9d, 0xe3, 0xa8, 0x93,
	0x82, 0xef, 0x09, 0x79, 0x7d, 0x62, 0x0c, 0xd5, 0x78, 0x09, 0xee, 0x03, 0xa0, 0x62, 0x7b, 0xa4,
	0x0d, 0x70, 0x73, 0x34, 0xa2, 0xf7, 0x2b, 0xb4, 0x2a, 0xbe, 0x27, 0x94, 0x9c, 0xb0, 0xda, 0xd7,
	0x46, 0x23, 0x35, 0x21, 0x81, 0xbb, 0x00, 0x74, 0xdc, 0xb6, 0x35, 0xb6, 0x47, 0x98, 0x60, 0x94,
	0xa7, 0x86, 0x65, 0xdf, 0x13, 0x0a, 0x83, 0xa8, 0xa6, 0x26, 0xd6, 0xe1, 0x2b, 0xb0, 0x74, 0x69,
	0xbb, 0xd8, 0x21, 0x2e, 0x5a, 0xd8, 0x9e, 0xdf, 0x29, 0x49, 0xab, 0x7b, 0xf4, 0xab, 0xd9, 0xbb,
	0xd0, 0xf4, 0x70, 0xa1, 0x55, 0xf9, 0xec, 0x09, 0x73, 0xbe, 0x27, 0x2c, 0x4d, 0x42, 0xa1, 0xca,
	0x1c, 0x81, 0xf9, 0x18, 0x07, 0x18, 0x17, 0x2d, 0xf2, 0xe6, 0x70, 0x21, 0x36, 0x0f, 0x43, 0xa1,
	0xca, 0x1c, 0xc1, 0x07, 0xbb, 0xb8, 0x78, 0xfb, 0xce, 0x30, 0x27, 0x81, 0x7f, 0x69, 0x3b, 0xb7,
	0x53, 0x0e, 0x3f, 0x18, 0x21, 0xa3, 0xfe, 0x38, 0x2c, 0xab, 0x09, 0x09, 0x6c, 0x82, 0xc5, 0x30,
	0x09, 0xa8, 0xb0, 0x9d, 0xdb, 0x29, 0x49, 0x9b, 0xf1, 0xcd, 0xb8, 0xa8, 0xb4, 0x56, 0xa2, 0xbb,
	0x2e, 0xba, 0xf4, 0x5a, 0x8d, 0x8c, 0x7f, 0xcc, 0x17, 0x72, 0xab, 0x0f, 0x6a, 0x7f, 0x02, 0xf0,
	0xcd, 0x08, 0xdf, 0xf4, 0x88, 0x63, 0x98, 0x7a, 0xdb, 0x31, 0x08, 0x76, 0x0c, 0x0d, 0xd6, 0xc0,
	0x62, 0x73, 0x40, 0x0c, 0xcb, 0x8c, 0x92, 0x05, 0x02, 0xbf, 0x46, 0x2b, 0x6a, 0xb4, 0x02, 0x05,
	0xb0, 0xf0, 0x5e, 0x1b, 0x4d, 0x58, 0x74, 0x8a, 0xbe, 0x27, 0x2c, 0x5c, 0x07, 0x05, 0x35, 0xac,
	0xd7, 0xfe, 0xb9, 0x09, 0x4a, 0x17, 0x5a, 0x0c, 0x7d, 0x0e, 0x8a, 0xc7, 0x86, 0x83, 0x93, 0xdc,
	0xb2, 0xef, 0x09, 0xc5, 0x21, 0x2b, 0xaa, 0xf1, 0x3a, 0x94, 0x00, 0xe8, 0x5a, 0x0e, 0x51, 0x35,
	0x53, 0xc7, 0x2e, 0x7a, 0xb0, 0x3d, 0xbf, 0x53, 0x6c, 0x41, 0xdf, 0x13, 0x56, 0x6c, 0xcb, 0x21,
	0x89, 0x54, 0x25, 0x54, 0x50, 0x01, 0xc5, 0x6e, 0xb0, 0x69, 0x06, 0xd6, 0xc8, 0x45, 0xf3, 0xdb,
	0xf3, 0x3b, 0xe5, 0xd6, 0x63, 0xdf, 0x13, 0xa0, 0x1d, 0x15, 0x13, 0xb6, 0x58, 0x08, 0xf7, 0x41,
	0xb1, 0xd9, 0x3b, 0x8f, 0x6e, 0x94, 0xa7, 0x37, 0x5a, 0xf3, 0x3d, 0xa1, 0xac, 0xb9, 0x66, 0xd2,
	0x30, 0xd5, 0x40, 0x19, 0x80, 0xf7, 0x6f, 0x35, 0x33, 0x72, 0x2c, 0x50, 0xc7, 0x43, 0xdf, 0x13,
	0x2a, 0xd7, 0x23, 0xcd, 0x74, 0x93, 0xbd, 0xc5, 0x32, 0x78, 0x0a, 0x2a, 0x6f, 0x35, 0x97, 0x9c,
	0x59, 0x76, 0xb3, 0x77, 0x1e, 0xec, 0x82, 0x30, 0x26, 0xc5, 0xd6, 0x13, 0xdf, 0x13, 0x36, 0x47,
	0x9a, 0x4b, 0xae, 0x2c, 0xbb, 0xaf, 0xb9, 0xfc, 0xae, 0xe1, 0x5d, 0xf0, 0x04, 0xac, 0x9e, 0xe3,
	0x9b, 0xa8, 0x14, 0xf5, 0xb0, 0x44, 0x49, 0x9b, 0xbe, 0x27, 0x3c, 0x32, 0xf1, 0x4d, 0x44, 0x4a,
	0x76, 0x9f, 0xb2, 0x04, 0xfd, 0xc4, 0xb5, 0xb0, 0x9f, 0x42, 0xdc, 0x4f, 0x4c, 0x49, 0xf5, 0xc3,
	0xb9, 0xe0, 0x21, 0x00, 0xad, 0xd3, 0x6e, 0xb3, 0xd7, 0xd5, 0xc8, 0x95, 0x8b, 0x8a, 0x94, 0x81,
	0x7c, 0x4f, 0x58, 0xff, 0xa0, 0x07, 0x7e, 0x5b, 0x23, 0x57, 0xc9, 0x47, 0x12, 0x6b, 0x61, 0x1b,
	0xac, 0xb4, 0x4e, 0xbb, 0x6d, 0x6b, 0x3c, 0x9e, 0x98, 0x06, 0x31, 0xb0, 0x8b, 0x00, 0x75, 0xff,
	0xe4, 0x7b, 0xc2, 0x46, 0xe0, 0x1e, 0x44, 0x4b, 0xb7, 0x09, 0x00, 0x67, 0x09, 0x06, 0xd0, 0x45,
	0xbb, 0xfb, 0x66, 0xa4, 0xe9, 0x2e, 0x2a, 0xd1, 0x7d, 0x43, 0x07, 0x10, 0x19, 0xd8, 0xfd, 0x8f,
	0x41, 0x31, 0x39, 0x80, 0x98, 0x10, 0x2a, 0xa0, 0xd4, 0xe9, 0x36, 0x87, 0x43, 0x07, 0xbb, 0x2e,
	0x76, 0xd1, 0x72, 0x9c, 0x2e, 0x6d, 0x38, 0x74, 0x92, 0x53, 0x33, 0x21, 0x83, 0x0d, 0xb0, 0xfc,
	0xae, 0xd9, 0x8e, 0x6d, 0xe5, 0x38, 0x2b, 0x63, 0x6d, 0x90, 0x70, 0xcd, 0xc8, 0xe0, 0x11, 0x58,
	0x6e, 0x5b, 0x13, 0x93, 0x38, 0xb7, 0x6d, 0x6b, 0x88, 0x5d, 0xb4, 0x42, 0x6d, 0x8f, 0x7c, 0x4f,
	0x58, 0x1b, 0x84, 0xf5, 0xa4, 0x35, 0x29, 0x85, 0xaf, 0x41, 0xa5, 0x67, 0x10, 0x3a, 0xb3, 0x55,
	0xac, 0xe3, 0x1b, 0xec, 0xa2, 0x4a, 0xdc, 0xab, 0x6b, 0x90, 0xd9, 0xd9, 0x3c, 0x2b, 0x85, 0xa7,
	0x60, 0xed, 0x18, 0x07, 0xd3, 0xfa, 0xe2, 0xd6, 0x9e, 0xfa, 0x57, 0xe3, 0xa8, 0x0c, 0xe9, 0x62,
	0x9f, 0xdc, 0xda, 0x49, 0x4c, 0xda, 0x03, 0xbb, 0x60, 0xbd, 0x63, 0x12, 0xec, 0x7c, 0xd4, 0x06,
	0x33, 0xbd, 0xac, 0x51, 0xd6, 0xcf, 0xbe, 0x27, 0x20, 0x83, 0xad, 0xf3, 0x79, 0xb9, 0xd7, 0x19,
	0xb7, 0x96, 0xc4, 0xc1, 0x54, 0x6b, 0x1c, 0x2b, 0xed, 0x81, 0x27, 0x00, 0x46, 0x81, 0x4c, 0x7e,
	0xa1, 0x0f, 0xe3, 0x47, 0x1c, 0x25, 0x39, 0x41, 0xb9, 0xc7, 0x00, 0xcf, 0xc0, 0x42, 0x8f, 0x38,
	0xf5, 0x3a, 0x5a, 0xa7, 0xa3, 0x9b, 0x4d, 0xd3, 0xf4, 0x64, 0x6c, 0x6d, 0x44, 0xd3, 0xb4, 0xe2,
	0x06, 0xfa, 0x04, 0x36, 0x04, 0x30, 0x92, 0x88, 0x1e, 0x65, 0x22, 0x89, 0x3c, 0x49, 0x64, 0x24,
	0x09, 0x3d, 0xce, 0x44, 0x92, 0x78, 0x92, 0xc4, 0x48, 0x32, 0xda, 0xc8, 0x44, 0x92, 0x79, 0x92,
	0xcc, 0x48, 0x0a, 0x42, 0x99, 0x48, 0x0a, 0x4f, 0x52, 0x18, 0xa9, 0x81, 0x36, 0x33, 0x91, 0x1a,
	0x3c, 0xa9, 0xc1, 0x48, 0x07, 0x68, 0x2b, 0x13, 0xe9, 0x80, 0x27, 0x1d, 0x30, 0xd2, 0x4b, 0xf4,
	0x53, 0x26, 0xd2, 0x4b, 0x9e, 0xf4, 0x92, 0x91, 0x0e, 0xd1, 0xcf, 0x99, 0x48, 0x87, 0x3c, 0xe9,
	0x90, 0x91, 0x8e, 0xd0, 0x93, 0x4c, 0xa4, 0x23, 0x9e, 0x74, 0x14, 0x91, 0xc4, 0x3a, 0xaa, 0x66,
	0x21, 0x89, 0x7c, 0xc6, 0x45, 0x96, 0x71, 0x51, 0x44, 0x42, 0x26, 0x12, 0x9f, 0x71, 0x91, 0x65,
	0x5c, 0x94, 0xd0, 0x76, 0x26, 0x12, 0x9f, 0x71, 0x91, 0x65, 0x5c, 0x94, 0xd1, 0xaf, 0x32, 0x91,
	0xf8, 0x8c, 0x8b, 0x2c, 0xe3, 0xa2, 0x82, 0x6a, 0x99, 0x48, 0x7c, 0xc6, 0x45, 0x96, 0x71, 0xb1,
	0x81, 0x7e, 0x9d, 0x89, 0xc4, 0x67, 0x5c, 0x64, 0x19, 0x17, 0x0f, 0xd0, 0x6f, 0x32, 0x91, 0xf8,
	0x8c, 0x8b, 0x07, 0xb0, 0x0e, 0x96, 0x3a, 0x26, 0x39, 0x50, 0xea, 0x75, 0xf4, 0x5b, 0x3a, 0x25,
	0xe9, 0x1b, 0x92, 0x11, 0x94, 0xfa, 0x33, 0xf3, 0x8c, 0xc9, 0x62, 0x87, 0x88, 0x9e, 0xa6, 0x1c,
	0x62, 0xda, 0x21, 0xc6, 0x0e, 0x09, 0xfd, 0x2e, 0xe5, 0x90, 0xd2, 0x0e, 0x29, 0x76, 0xc8, 0x68,
	0x27, 0xe5, 0x90, 0xd3, 0x0e, 0x39, 0x76, 0x28, 0xe8, 0x59, 0xca, 0xa1, 0xa4, 0x1d, 0x4a, 0x70,
	0x64, 0x6a, 0xda, 0x36, 0x7b, 0xef, 0x43, 0xbf, 0xa7, 0x2e, 0x7a, 0x64, 0xd2, 0x6c, 0xbb, 0x7f,
	0xcf, 0x3b, 0x62, 0x52, 0x0e, 0x9f, 0x81, 0x85, 0x8e, 0x49, 0xea, 0x75, 0xf4, 0x3c, 0x7e, 0xdf,
	0x33, 0x82, 0x42, 0xf2, 0x11, 0x53, 0x05, 0x93, 0x8a, 0x68, 0x77, 0x56, 0x2a, 0xf2, 0x52, 0x91,
	0x49, 0x25, 0xf4, 0x62, 0x56, 0x2a, 0xf1, 0x52, 0x89, 0x49, 0x65, 0xb4, 0x37, 0x2b, 0x95, 0x79,
	0xa9, 0xcc, 0xa4, 0x0a, 0xda, 0x9f, 0x95, 0x2a, 0xbc, 0x54, 0x61, 0xd2, 0x06, 0xaa, 0xcf, 0x4a,
	0x1b, 0xbc, 0xb4, 0x01, 0x5f, 0x80, 0xc5, 0x8e, 0x89, 0x83, 0x47, 0x20, 0xc6, 0xff, 0xbd, 0x1a,
	0x26, 0x26, 0xb3, 0xb9, 0x89, 0x44, 0x53, 0xb9, 0x88, 0x24, 0x5e, 0x2e, 0xa6, 0xe4, 0xe2, 0x54,
	0x2e, 0x21, 0x99, 0x97, 0x4b, 0x29, 0xb9, 0x34, 0x95, 0xcb, 0x48, 0xe1, 0xe5, 0x72, 0x4a, 0x2e,
	0x4f, 0xe5, 0x0a, 0x6a, 0xf0, 0x72, 0x25, 0x25, 0x57, 0x6a, 0x26, 0x28, 0x4e, 0x8f, 0x7c, 0xf1,
	0x39, 0x27, 0x77, 0xff, 0x39, 0x07, 0xfe, 0x01, 0x14, 0xd8, 0xf6, 0xa3, 0x07, 0x95, 0x92, 0x04,
	0xe3, 0xd3, 0xd8, 0x74, 0x63, 0xae, 0x46, 0x1b, 0xb3, 0x30, 0x88, 0x2a, 0xea, 0xd4, 0x55, 0xdb,
	0xa5, 0xf7, 0x0b, 0x0f, 0x83, 0xff, 0xf3, 0x7e, 0x35, 0x09, 0x14, 0xd8, 0x7b, 0x3c, 0x5c, 0x0f,
	0x06, 0x83, 0xe6, 0x10, 0x2a, 0x2e, 0xab, 0xe1, 0x05, 0x5c, 0x05, 0xf3, 0x27, 0xe6, 0x90, 0x1e,
	0xcc, 0xca, 0x6a, 0xf0, 0x67, 0x4d, 0x06, 0xc5, 0xe9, 0x61, 0x24, 0x8b, 0x69, 0x7a, 0xba, 0xfa,
	0xbf, 0x4d, 0x47, 0xa0, 0x12, 0x8c, 0xa5, 0x4b, 0xc3, 0x24, 0xb2, 0xf4, 0x8b, 0xad, 0x07, 0xca,
	0x3d, 0xd6, 0xfc, 0x3d, 0xd6, 0x7c, 0x68, 0xfd, 0x7b, 0x0e, 0xac, 0x35, 0xbb, 0x9d, 0x1e, 0x76,
	0xae, 0xb1, 0xa3, 0x62, 0xd7, 0xb6, 0x4c, 0x17, 0xc3, 0xa7, 0x20, 0x4f, 0x7f, 0x52, 0x08, 0x9f,
	0x24, 0x7d, 0x69, 0xd6, 0x27, 0xc6, 0x30, 0xf1, 0x8d, 0xe7, 0xa3, 0xdf, 0x15, 0x96, 0xde, 0x61,
	0xd7, 0xd5, 0x74, 0x76, 0x98, 0xa5, 0xf9, 0x18, 0x87, 0xa5, 0xe4, 0x2c, 0x89, 0x54, 0xc1, 0xb6,
	0x39, 0x71, 0x1c, 0xcb, 0x89, 0x7e, 0xf3, 0xa0, 0xdb, 0x06, 0x07, 0x85, 0xe4, 0xb6, 0xa1, 0x8a,
	0xd6, 0xe5, 0x97, 0x6f, 0xd5, 0xb9, 0xaf, 0xdf, 0xaa, 0x73, 0x3f, 0xbe, 0x55, 0x73, 0x7f, 0xb9,
	0xab, 0xe6, 0xfe, 0x71, 0x57, 0xcd, 0x7d, 0xbe, 0xab, 0xe6, 0xbe, 0xdc, 0x55, 0x73, 0xff, 0xbe,
	0xab, 0xe6, 0xfe, 0x73, 0x57, 0x9d, 0xfb, 0x71, 0x57, 0xcd, 0xfd, 0xed, 0x7b, 0x75, 0xee, 0xcb,
	0xf7, 0xea, 0xdc, 0xd7, 0xef, 0xd5, 0xb9, 0x3f, 0x0b, 0xba, 0x41, 0xae, 0x26, 0x1f, 0xf6, 0x06,
	0xd6, 0x78, 0xff, 0x13, 0x36, 0x89, 0xf1, 0x69, 0x5f, 0xb7, 0x68, 0xa8, 0x5e, 0xd1, 0x7f, 0x3f,
	0x2c, 0xd2, 0x81, 0x25, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x86, 0xe6, 0xaa, 0xe5, 0x4c, 0x12,
	0x00, 0x00,
}

func (this *TagBatchPartSender) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagBatchPartSender)
	if !ok {
		that2, ok := that.(TagBatchPartSender)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.ServiceInstance != that1.ServiceInstance {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	return true
}
func (this *TagBatchPart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagBatchPart)
	if !ok {
		that2, ok := that.(TagBatchPart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchGUID != that1.BatchGUID {
		return false
	}
	if this.ReplaceAll != that1.ReplaceAll {
		return false
	}
	if this.IsComplete != that1.IsComplete {
		return false
	}
	if len(this.Upserts) != len(that1.Upserts) {
		return false
	}
	for i := range this.Upserts {
		if !this.Upserts[i].Equal(&that1.Upserts[i]) {
			return false
		}
	}
	if len(this.Deletes) != len(that1.Deletes) {
		return false
	}
	for i := range this.Deletes {
		if !this.Deletes[i].Equal(&that1.Deletes[i]) {
			return false
		}
	}
	if this.TTLMinutes != that1.TTLMinutes {
		return false
	}
	if !this.Sender.Equal(&that1.Sender) {
		return false
	}
	return true
}
func (this *FlexStringCriteria) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlexStringCriteria)
	if !ok {
		that2, ok := that.(FlexStringCriteria)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TagCriteria) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagCriteria)
	if !ok {
		that2, ok := that.(TagCriteria)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if len(this.PortRanges) != len(that1.PortRanges) {
		return false
	}
	for i := range this.PortRanges {
		if this.PortRanges[i] != that1.PortRanges[i] {
			return false
		}
	}
	if len(this.Protocols) != len(that1.Protocols) {
		return false
	}
	for i := range this.Protocols {
		if this.Protocols[i] != that1.Protocols[i] {
			return false
		}
	}
	if len(this.ASNRanges) != len(that1.ASNRanges) {
		return false
	}
	for i := range this.ASNRanges {
		if this.ASNRanges[i] != that1.ASNRanges[i] {
			return false
		}
	}
	if len(this.VLanRanges) != len(that1.VLanRanges) {
		return false
	}
	for i := range this.VLanRanges {
		if this.VLanRanges[i] != that1.VLanRanges[i] {
			return false
		}
	}
	if len(this.LastHopASNNames) != len(that1.LastHopASNNames) {
		return false
	}
	for i := range this.LastHopASNNames {
		if this.LastHopASNNames[i] != that1.LastHopASNNames[i] {
			return false
		}
	}
	if len(this.NextHopASNRanges) != len(that1.NextHopASNRanges) {
		return false
	}
	for i := range this.NextHopASNRanges {
		if this.NextHopASNRanges[i] != that1.NextHopASNRanges[i] {
			return false
		}
	}
	if len(this.NextHopASNNames) != len(that1.NextHopASNNames) {
		return false
	}
	for i := range this.NextHopASNNames {
		if this.NextHopASNNames[i] != that1.NextHopASNNames[i] {
			return false
		}
	}
	if len(this.BGPASPaths) != len(that1.BGPASPaths) {
		return false
	}
	for i := range this.BGPASPaths {
		if this.BGPASPaths[i] != that1.BGPASPaths[i] {
			return false
		}
	}
	if len(this.BGPCommunities) != len(that1.BGPCommunities) {
		return false
	}
	for i := range this.BGPCommunities {
		if this.BGPCommunities[i] != that1.BGPCommunities[i] {
			return false
		}
	}
	if this.TCPFlags != that1.TCPFlags {
		return false
	}
	if len(this.IPAddresses) != len(that1.IPAddresses) {
		return false
	}
	for i := range this.IPAddresses {
		if this.IPAddresses[i] != that1.IPAddresses[i] {
			return false
		}
	}
	if len(this.MACAddresses) != len(that1.MACAddresses) {
		return false
	}
	for i := range this.MACAddresses {
		if this.MACAddresses[i] != that1.MACAddresses[i] {
			return false
		}
	}
	if len(this.CountryCodes) != len(that1.CountryCodes) {
		return false
	}
	for i := range this.CountryCodes {
		if this.CountryCodes[i] != that1.CountryCodes[i] {
			return false
		}
	}
	if len(this.SiteNameRegexes) != len(that1.SiteNameRegexes) {
		return false
	}
	for i := range this.SiteNameRegexes {
		if this.SiteNameRegexes[i] != that1.SiteNameRegexes[i] {
			return false
		}
	}
	if len(this.DeviceTypeRegexes) != len(that1.DeviceTypeRegexes) {
		return false
	}
	for i := range this.DeviceTypeRegexes {
		if this.DeviceTypeRegexes[i] != that1.DeviceTypeRegexes[i] {
			return false
		}
	}
	if len(this.InterfaceNameRegexes) != len(that1.InterfaceNameRegexes) {
		return false
	}
	for i := range this.InterfaceNameRegexes {
		if this.InterfaceNameRegexes[i] != that1.InterfaceNameRegexes[i] {
			return false
		}
	}
	if len(this.DeviceNameRegexes) != len(that1.DeviceNameRegexes) {
		return false
	}
	for i := range this.DeviceNameRegexes {
		if this.DeviceNameRegexes[i] != that1.DeviceNameRegexes[i] {
			return false
		}
	}
	if len(this.NextHopIPAddresses) != len(that1.NextHopIPAddresses) {
		return false
	}
	for i := range this.NextHopIPAddresses {
		if this.NextHopIPAddresses[i] != that1.NextHopIPAddresses[i] {
			return false
		}
	}
	if len(this.Str00) != len(that1.Str00) {
		return false
	}
	for i := range this.Str00 {
		if !this.Str00[i].Equal(&that1.Str00[i]) {
			return false
		}
	}
	if len(this.Str01) != len(that1.Str01) {
		return false
	}
	for i := range this.Str01 {
		if !this.Str01[i].Equal(&that1.Str01[i]) {
			return false
		}
	}
	if len(this.Str02) != len(that1.Str02) {
		return false
	}
	for i := range this.Str02 {
		if !this.Str02[i].Equal(&that1.Str02[i]) {
			return false
		}
	}
	if len(this.Str03) != len(that1.Str03) {
		return false
	}
	for i := range this.Str03 {
		if !this.Str03[i].Equal(&that1.Str03[i]) {
			return false
		}
	}
	if len(this.Str04) != len(that1.Str04) {
		return false
	}
	for i := range this.Str04 {
		if !this.Str04[i].Equal(&that1.Str04[i]) {
			return false
		}
	}
	if len(this.Str05) != len(that1.Str05) {
		return false
	}
	for i := range this.Str05 {
		if !this.Str05[i].Equal(&that1.Str05[i]) {
			return false
		}
	}
	if len(this.Str06) != len(that1.Str06) {
		return false
	}
	for i := range this.Str06 {
		if !this.Str06[i].Equal(&that1.Str06[i]) {
			return false
		}
	}
	if len(this.Str07) != len(that1.Str07) {
		return false
	}
	for i := range this.Str07 {
		if !this.Str07[i].Equal(&that1.Str07[i]) {
			return false
		}
	}
	if len(this.Str08) != len(that1.Str08) {
		return false
	}
	for i := range this.Str08 {
		if !this.Str08[i].Equal(&that1.Str08[i]) {
			return false
		}
	}
	if len(this.Str09) != len(that1.Str09) {
		return false
	}
	for i := range this.Str09 {
		if !this.Str09[i].Equal(&that1.Str09[i]) {
			return false
		}
	}
	if len(this.Str10) != len(that1.Str10) {
		return false
	}
	for i := range this.Str10 {
		if !this.Str10[i].Equal(&that1.Str10[i]) {
			return false
		}
	}
	if len(this.Str11) != len(that1.Str11) {
		return false
	}
	for i := range this.Str11 {
		if !this.Str11[i].Equal(&that1.Str11[i]) {
			return false
		}
	}
	if len(this.Str12) != len(that1.Str12) {
		return false
	}
	for i := range this.Str12 {
		if !this.Str12[i].Equal(&that1.Str12[i]) {
			return false
		}
	}
	if len(this.Str13) != len(that1.Str13) {
		return false
	}
	for i := range this.Str13 {
		if !this.Str13[i].Equal(&that1.Str13[i]) {
			return false
		}
	}
	if len(this.Str14) != len(that1.Str14) {
		return false
	}
	for i := range this.Str14 {
		if !this.Str14[i].Equal(&that1.Str14[i]) {
			return false
		}
	}
	if len(this.Str15) != len(that1.Str15) {
		return false
	}
	for i := range this.Str15 {
		if !this.Str15[i].Equal(&that1.Str15[i]) {
			return false
		}
	}
	if len(this.Str16) != len(that1.Str16) {
		return false
	}
	for i := range this.Str16 {
		if !this.Str16[i].Equal(&that1.Str16[i]) {
			return false
		}
	}
	if len(this.Int6400) != len(that1.Int6400) {
		return false
	}
	for i := range this.Int6400 {
		if this.Int6400[i] != that1.Int6400[i] {
			return false
		}
	}
	if len(this.Int6401) != len(that1.Int6401) {
		return false
	}
	for i := range this.Int6401 {
		if this.Int6401[i] != that1.Int6401[i] {
			return false
		}
	}
	if len(this.Int6402) != len(that1.Int6402) {
		return false
	}
	for i := range this.Int6402 {
		if this.Int6402[i] != that1.Int6402[i] {
			return false
		}
	}
	if len(this.Int6403) != len(that1.Int6403) {
		return false
	}
	for i := range this.Int6403 {
		if this.Int6403[i] != that1.Int6403[i] {
			return false
		}
	}
	if len(this.Int6404) != len(that1.Int6404) {
		return false
	}
	for i := range this.Int6404 {
		if this.Int6404[i] != that1.Int6404[i] {
			return false
		}
	}
	if len(this.AppProtocol) != len(that1.AppProtocol) {
		return false
	}
	for i := range this.AppProtocol {
		if this.AppProtocol[i] != that1.AppProtocol[i] {
			return false
		}
	}
	if len(this.Int00) != len(that1.Int00) {
		return false
	}
	for i := range this.Int00 {
		if this.Int00[i] != that1.Int00[i] {
			return false
		}
	}
	if len(this.Int01) != len(that1.Int01) {
		return false
	}
	for i := range this.Int01 {
		if this.Int01[i] != that1.Int01[i] {
			return false
		}
	}
	if len(this.Int02) != len(that1.Int02) {
		return false
	}
	for i := range this.Int02 {
		if this.Int02[i] != that1.Int02[i] {
			return false
		}
	}
	if len(this.Int03) != len(that1.Int03) {
		return false
	}
	for i := range this.Int03 {
		if this.Int03[i] != that1.Int03[i] {
			return false
		}
	}
	if len(this.Int04) != len(that1.Int04) {
		return false
	}
	for i := range this.Int04 {
		if this.Int04[i] != that1.Int04[i] {
			return false
		}
	}
	if len(this.Int05) != len(that1.Int05) {
		return false
	}
	for i := range this.Int05 {
		if this.Int05[i] != that1.Int05[i] {
			return false
		}
	}
	if len(this.Inet00) != len(that1.Inet00) {
		return false
	}
	for i := range this.Inet00 {
		if this.Inet00[i] != that1.Inet00[i] {
			return false
		}
	}
	if len(this.Inet01) != len(that1.Inet01) {
		return false
	}
	for i := range this.Inet01 {
		if this.Inet01[i] != that1.Inet01[i] {
			return false
		}
	}
	if len(this.Inet02) != len(that1.Inet02) {
		return false
	}
	for i := range this.Inet02 {
		if this.Inet02[i] != that1.Inet02[i] {
			return false
		}
	}
	if len(this.Inet03) != len(that1.Inet03) {
		return false
	}
	for i := range this.Inet03 {
		if this.Inet03[i] != that1.Inet03[i] {
			return false
		}
	}
	if len(this.Inet04) != len(that1.Inet04) {
		return false
	}
	for i := range this.Inet04 {
		if this.Inet04[i] != that1.Inet04[i] {
			return false
		}
	}
	return true
}
func (this *TagUpsert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagUpsert)
	if !ok {
		that2, ok := that.(TagUpsert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if len(this.Criteria) != len(that1.Criteria) {
		return false
	}
	for i := range this.Criteria {
		if !this.Criteria[i].Equal(&that1.Criteria[i]) {
			return false
		}
	}
	return true
}
func (this *TagDelete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagDelete)
	if !ok {
		that2, ok := that.(TagDelete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ASNRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ASNRange)
	if !ok {
		that2, ok := that.(ASNRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *VLanRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VLanRange)
	if !ok {
		that2, ok := that.(VLanRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *PortRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortRange)
	if !ok {
		that2, ok := that.(PortRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *FlexUint32Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlexUint32Range)
	if !ok {
		that2, ok := that.(FlexUint32Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *FlexUint64Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlexUint64Range)
	if !ok {
		that2, ok := that.(FlexUint64Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *APIServerResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APIServerResponse)
	if !ok {
		that2, ok := that.(APIServerResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GUID != that1.GUID {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *TagBatchPartSender) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&hippo.TagBatchPartSender{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "ServiceInstance: "+fmt.Sprintf("%#v", this.ServiceInstance)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagBatchPart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&hippo.TagBatchPart{")
	s = append(s, "BatchGUID: "+fmt.Sprintf("%#v", this.BatchGUID)+",\n")
	s = append(s, "ReplaceAll: "+fmt.Sprintf("%#v", this.ReplaceAll)+",\n")
	s = append(s, "IsComplete: "+fmt.Sprintf("%#v", this.IsComplete)+",\n")
	if this.Upserts != nil {
		vs := make([]TagUpsert, len(this.Upserts))
		for i := range vs {
			vs[i] = this.Upserts[i]
		}
		s = append(s, "Upserts: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Deletes != nil {
		vs := make([]TagDelete, len(this.Deletes))
		for i := range vs {
			vs[i] = this.Deletes[i]
		}
		s = append(s, "Deletes: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "TTLMinutes: "+fmt.Sprintf("%#v", this.TTLMinutes)+",\n")
	s = append(s, "Sender: "+strings.Replace(this.Sender.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlexStringCriteria) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.FlexStringCriteria{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagCriteria) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 57)
	s = append(s, "&hippo.TagCriteria{")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "Protocols: "+fmt.Sprintf("%#v", this.Protocols)+",\n")
	s = append(s, "ASNRanges: "+fmt.Sprintf("%#v", this.ASNRanges)+",\n")
	s = append(s, "VLanRanges: "+fmt.Sprintf("%#v", this.VLanRanges)+",\n")
	s = append(s, "LastHopASNNames: "+fmt.Sprintf("%#v", this.LastHopASNNames)+",\n")
	s = append(s, "NextHopASNRanges: "+fmt.Sprintf("%#v", this.NextHopASNRanges)+",\n")
	s = append(s, "NextHopASNNames: "+fmt.Sprintf("%#v", this.NextHopASNNames)+",\n")
	s = append(s, "BGPASPaths: "+fmt.Sprintf("%#v", this.BGPASPaths)+",\n")
	s = append(s, "BGPCommunities: "+fmt.Sprintf("%#v", this.BGPCommunities)+",\n")
	s = append(s, "TCPFlags: "+fmt.Sprintf("%#v", this.TCPFlags)+",\n")
	s = append(s, "IPAddresses: "+fmt.Sprintf("%#v", this.IPAddresses)+",\n")
	s = append(s, "MACAddresses: "+fmt.Sprintf("%#v", this.MACAddresses)+",\n")
	s = append(s, "CountryCodes: "+fmt.Sprintf("%#v", this.CountryCodes)+",\n")
	s = append(s, "SiteNameRegexes: "+fmt.Sprintf("%#v", this.SiteNameRegexes)+",\n")
	s = append(s, "DeviceTypeRegexes: "+fmt.Sprintf("%#v", this.DeviceTypeRegexes)+",\n")
	s = append(s, "InterfaceNameRegexes: "+fmt.Sprintf("%#v", this.InterfaceNameRegexes)+",\n")
	s = append(s, "DeviceNameRegexes: "+fmt.Sprintf("%#v", this.DeviceNameRegexes)+",\n")
	s = append(s, "NextHopIPAddresses: "+fmt.Sprintf("%#v", this.NextHopIPAddresses)+",\n")
	if this.Str00 != nil {
		vs := make([]FlexStringCriteria, len(this.Str00))
		for i := range vs {
			vs[i] = this.Str00[i]
		}
		s = append(s, "Str00: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str01 != nil {
		vs := make([]FlexStringCriteria, len(this.Str01))
		for i := range vs {
			vs[i] = this.Str01[i]
		}
		s = append(s, "Str01: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str02 != nil {
		vs := make([]FlexStringCriteria, len(this.Str02))
		for i := range vs {
			vs[i] = this.Str02[i]
		}
		s = append(s, "Str02: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str03 != nil {
		vs := make([]FlexStringCriteria, len(this.Str03))
		for i := range vs {
			vs[i] = this.Str03[i]
		}
		s = append(s, "Str03: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str04 != nil {
		vs := make([]FlexStringCriteria, len(this.Str04))
		for i := range vs {
			vs[i] = this.Str04[i]
		}
		s = append(s, "Str04: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str05 != nil {
		vs := make([]FlexStringCriteria, len(this.Str05))
		for i := range vs {
			vs[i] = this.Str05[i]
		}
		s = append(s, "Str05: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str06 != nil {
		vs := make([]FlexStringCriteria, len(this.Str06))
		for i := range vs {
			vs[i] = this.Str06[i]
		}
		s = append(s, "Str06: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str07 != nil {
		vs := make([]FlexStringCriteria, len(this.Str07))
		for i := range vs {
			vs[i] = this.Str07[i]
		}
		s = append(s, "Str07: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str08 != nil {
		vs := make([]FlexStringCriteria, len(this.Str08))
		for i := range vs {
			vs[i] = this.Str08[i]
		}
		s = append(s, "Str08: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str09 != nil {
		vs := make([]FlexStringCriteria, len(this.Str09))
		for i := range vs {
			vs[i] = this.Str09[i]
		}
		s = append(s, "Str09: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str10 != nil {
		vs := make([]FlexStringCriteria, len(this.Str10))
		for i := range vs {
			vs[i] = this.Str10[i]
		}
		s = append(s, "Str10: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str11 != nil {
		vs := make([]FlexStringCriteria, len(this.Str11))
		for i := range vs {
			vs[i] = this.Str11[i]
		}
		s = append(s, "Str11: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str12 != nil {
		vs := make([]FlexStringCriteria, len(this.Str12))
		for i := range vs {
			vs[i] = this.Str12[i]
		}
		s = append(s, "Str12: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str13 != nil {
		vs := make([]FlexStringCriteria, len(this.Str13))
		for i := range vs {
			vs[i] = this.Str13[i]
		}
		s = append(s, "Str13: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str14 != nil {
		vs := make([]FlexStringCriteria, len(this.Str14))
		for i := range vs {
			vs[i] = this.Str14[i]
		}
		s = append(s, "Str14: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str15 != nil {
		vs := make([]FlexStringCriteria, len(this.Str15))
		for i := range vs {
			vs[i] = this.Str15[i]
		}
		s = append(s, "Str15: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Str16 != nil {
		vs := make([]FlexStringCriteria, len(this.Str16))
		for i := range vs {
			vs[i] = this.Str16[i]
		}
		s = append(s, "Str16: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Int6400: "+fmt.Sprintf("%#v", this.Int6400)+",\n")
	s = append(s, "Int6401: "+fmt.Sprintf("%#v", this.Int6401)+",\n")
	s = append(s, "Int6402: "+fmt.Sprintf("%#v", this.Int6402)+",\n")
	s = append(s, "Int6403: "+fmt.Sprintf("%#v", this.Int6403)+",\n")
	s = append(s, "Int6404: "+fmt.Sprintf("%#v", this.Int6404)+",\n")
	s = append(s, "AppProtocol: "+fmt.Sprintf("%#v", this.AppProtocol)+",\n")
	s = append(s, "Int00: "+fmt.Sprintf("%#v", this.Int00)+",\n")
	s = append(s, "Int01: "+fmt.Sprintf("%#v", this.Int01)+",\n")
	s = append(s, "Int02: "+fmt.Sprintf("%#v", this.Int02)+",\n")
	s = append(s, "Int03: "+fmt.Sprintf("%#v", this.Int03)+",\n")
	s = append(s, "Int04: "+fmt.Sprintf("%#v", this.Int04)+",\n")
	s = append(s, "Int05: "+fmt.Sprintf("%#v", this.Int05)+",\n")
	s = append(s, "Inet00: "+fmt.Sprintf("%#v", this.Inet00)+",\n")
	s = append(s, "Inet01: "+fmt.Sprintf("%#v", this.Inet01)+",\n")
	s = append(s, "Inet02: "+fmt.Sprintf("%#v", this.Inet02)+",\n")
	s = append(s, "Inet03: "+fmt.Sprintf("%#v", this.Inet03)+",\n")
	s = append(s, "Inet04: "+fmt.Sprintf("%#v", this.Inet04)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagUpsert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.TagUpsert{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Criteria != nil {
		vs := make([]TagCriteria, len(this.Criteria))
		for i := range vs {
			vs[i] = this.Criteria[i]
		}
		s = append(s, "Criteria: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagDelete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&hippo.TagDelete{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ASNRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.ASNRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VLanRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.VLanRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.PortRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlexUint32Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.FlexUint32Range{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlexUint64Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&hippo.FlexUint64Range{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *APIServerResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&hippo.APIServerResponse{")
	s = append(s, "GUID: "+fmt.Sprintf("%#v", this.GUID)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTagging(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TagBatchPartSender) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagBatchPartSender) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagBatchPartSender) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceInstance) > 0 {
		i -= len(m.ServiceInstance)
		copy(dAtA[i:], m.ServiceInstance)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.ServiceInstance)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagBatchPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagBatchPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagBatchPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTagging(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.TTLMinutes != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.TTLMinutes))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Deletes) > 0 {
		for iNdEx := len(m.Deletes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deletes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Upserts) > 0 {
		for iNdEx := len(m.Upserts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Upserts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IsComplete {
		i--
		if m.IsComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReplaceAll {
		i--
		if m.ReplaceAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.BatchGUID) > 0 {
		i -= len(m.BatchGUID)
		copy(dAtA[i:], m.BatchGUID)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.BatchGUID)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FlexStringCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlexStringCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlexStringCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inet04) > 0 {
		for iNdEx := len(m.Inet04) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inet04[iNdEx])
			copy(dAtA[i:], m.Inet04[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Inet04[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Inet03) > 0 {
		for iNdEx := len(m.Inet03) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inet03[iNdEx])
			copy(dAtA[i:], m.Inet03[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Inet03[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Inet02) > 0 {
		for iNdEx := len(m.Inet02) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inet02[iNdEx])
			copy(dAtA[i:], m.Inet02[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Inet02[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Inet01) > 0 {
		for iNdEx := len(m.Inet01) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inet01[iNdEx])
			copy(dAtA[i:], m.Inet01[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Inet01[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Inet00) > 0 {
		for iNdEx := len(m.Inet00) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inet00[iNdEx])
			copy(dAtA[i:], m.Inet00[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Inet00[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Int05) > 0 {
		for iNdEx := len(m.Int05) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int05[iNdEx])
			copy(dAtA[i:], m.Int05[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int05[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Int04) > 0 {
		for iNdEx := len(m.Int04) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int04[iNdEx])
			copy(dAtA[i:], m.Int04[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int04[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.Int03) > 0 {
		for iNdEx := len(m.Int03) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int03[iNdEx])
			copy(dAtA[i:], m.Int03[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int03[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.Int02) > 0 {
		for iNdEx := len(m.Int02) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int02[iNdEx])
			copy(dAtA[i:], m.Int02[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int02[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.Int01) > 0 {
		for iNdEx := len(m.Int01) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int01[iNdEx])
			copy(dAtA[i:], m.Int01[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int01[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.Int00) > 0 {
		for iNdEx := len(m.Int00) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int00[iNdEx])
			copy(dAtA[i:], m.Int00[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int00[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.AppProtocol) > 0 {
		for iNdEx := len(m.AppProtocol) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppProtocol[iNdEx])
			copy(dAtA[i:], m.AppProtocol[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.AppProtocol[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Int6404) > 0 {
		for iNdEx := len(m.Int6404) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int6404[iNdEx])
			copy(dAtA[i:], m.Int6404[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int6404[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Int6403) > 0 {
		for iNdEx := len(m.Int6403) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int6403[iNdEx])
			copy(dAtA[i:], m.Int6403[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int6403[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Int6402) > 0 {
		for iNdEx := len(m.Int6402) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int6402[iNdEx])
			copy(dAtA[i:], m.Int6402[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int6402[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Int6401) > 0 {
		for iNdEx := len(m.Int6401) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int6401[iNdEx])
			copy(dAtA[i:], m.Int6401[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int6401[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Int6400) > 0 {
		for iNdEx := len(m.Int6400) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Int6400[iNdEx])
			copy(dAtA[i:], m.Int6400[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.Int6400[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Str16) > 0 {
		for iNdEx := len(m.Str16) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str16[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Str15) > 0 {
		for iNdEx := len(m.Str15) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str15[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Str14) > 0 {
		for iNdEx := len(m.Str14) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str14[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Str13) > 0 {
		for iNdEx := len(m.Str13) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str13[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Str12) > 0 {
		for iNdEx := len(m.Str12) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str12[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Str11) > 0 {
		for iNdEx := len(m.Str11) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str11[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.Str10) > 0 {
		for iNdEx := len(m.Str10) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str10[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.Str09) > 0 {
		for iNdEx := len(m.Str09) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str09[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.Str08) > 0 {
		for iNdEx := len(m.Str08) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str08[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.Str07) > 0 {
		for iNdEx := len(m.Str07) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str07[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.Str06) > 0 {
		for iNdEx := len(m.Str06) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str06[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Str05) > 0 {
		for iNdEx := len(m.Str05) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str05[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Str04) > 0 {
		for iNdEx := len(m.Str04) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str04[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Str03) > 0 {
		for iNdEx := len(m.Str03) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str03[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Str02) > 0 {
		for iNdEx := len(m.Str02) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str02[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Str01) > 0 {
		for iNdEx := len(m.Str01) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str01[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Str00) > 0 {
		for iNdEx := len(m.Str00) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Str00[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.NextHopIPAddresses) > 0 {
		for iNdEx := len(m.NextHopIPAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NextHopIPAddresses[iNdEx])
			copy(dAtA[i:], m.NextHopIPAddresses[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.NextHopIPAddresses[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.DeviceNameRegexes) > 0 {
		for iNdEx := len(m.DeviceNameRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceNameRegexes[iNdEx])
			copy(dAtA[i:], m.DeviceNameRegexes[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.DeviceNameRegexes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.InterfaceNameRegexes) > 0 {
		for iNdEx := len(m.InterfaceNameRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InterfaceNameRegexes[iNdEx])
			copy(dAtA[i:], m.InterfaceNameRegexes[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.InterfaceNameRegexes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.DeviceTypeRegexes) > 0 {
		for iNdEx := len(m.DeviceTypeRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceTypeRegexes[iNdEx])
			copy(dAtA[i:], m.DeviceTypeRegexes[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.DeviceTypeRegexes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.SiteNameRegexes) > 0 {
		for iNdEx := len(m.SiteNameRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SiteNameRegexes[iNdEx])
			copy(dAtA[i:], m.SiteNameRegexes[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.SiteNameRegexes[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.CountryCodes) > 0 {
		for iNdEx := len(m.CountryCodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CountryCodes[iNdEx])
			copy(dAtA[i:], m.CountryCodes[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.CountryCodes[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.MACAddresses) > 0 {
		for iNdEx := len(m.MACAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MACAddresses[iNdEx])
			copy(dAtA[i:], m.MACAddresses[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.MACAddresses[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.IPAddresses) > 0 {
		for iNdEx := len(m.IPAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IPAddresses[iNdEx])
			copy(dAtA[i:], m.IPAddresses[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.IPAddresses[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.TCPFlags != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.TCPFlags))
		i--
		dAtA[i] = 0x58
	}
	if len(m.BGPCommunities) > 0 {
		for iNdEx := len(m.BGPCommunities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BGPCommunities[iNdEx])
			copy(dAtA[i:], m.BGPCommunities[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.BGPCommunities[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BGPASPaths) > 0 {
		for iNdEx := len(m.BGPASPaths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BGPASPaths[iNdEx])
			copy(dAtA[i:], m.BGPASPaths[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.BGPASPaths[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.NextHopASNNames) > 0 {
		for iNdEx := len(m.NextHopASNNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NextHopASNNames[iNdEx])
			copy(dAtA[i:], m.NextHopASNNames[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.NextHopASNNames[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.NextHopASNRanges) > 0 {
		for iNdEx := len(m.NextHopASNRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NextHopASNRanges[iNdEx])
			copy(dAtA[i:], m.NextHopASNRanges[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.NextHopASNRanges[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LastHopASNNames) > 0 {
		for iNdEx := len(m.LastHopASNNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LastHopASNNames[iNdEx])
			copy(dAtA[i:], m.LastHopASNNames[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.LastHopASNNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.VLanRanges) > 0 {
		for iNdEx := len(m.VLanRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VLanRanges[iNdEx])
			copy(dAtA[i:], m.VLanRanges[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.VLanRanges[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ASNRanges) > 0 {
		for iNdEx := len(m.ASNRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ASNRanges[iNdEx])
			copy(dAtA[i:], m.ASNRanges[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.ASNRanges[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Protocols) > 0 {
		dAtA3 := make([]byte, len(m.Protocols)*10)
		var j2 int
		for _, num := range m.Protocols {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTagging(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PortRanges) > 0 {
		for iNdEx := len(m.PortRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PortRanges[iNdEx])
			copy(dAtA[i:], m.PortRanges[iNdEx])
			i = encodeVarintTagging(dAtA, i, uint64(len(m.PortRanges[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Direction) > 0 {
		i -= len(m.Direction)
		copy(dAtA[i:], m.Direction)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Direction)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagUpsert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagUpsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagUpsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Criteria) > 0 {
		for iNdEx := len(m.Criteria) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Criteria[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTagging(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ASNRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ASNRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ASNRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VLanRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VLanRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VLanRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlexUint32Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlexUint32Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlexUint32Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlexUint64Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlexUint64Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlexUint64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintTagging(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *APIServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APIServerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APIServerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GUID) > 0 {
		i -= len(m.GUID)
		copy(dAtA[i:], m.GUID)
		i = encodeVarintTagging(dAtA, i, uint64(len(m.GUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTagging(dAtA []byte, offset int, v uint64) int {
	offset -= sovTagging(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TagBatchPartSender) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	l = len(m.ServiceInstance)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	return n
}

func (m *TagBatchPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchGUID)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	if m.ReplaceAll {
		n += 2
	}
	if m.IsComplete {
		n += 2
	}
	if len(m.Upserts) > 0 {
		for _, e := range m.Upserts {
			l = e.Size()
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Deletes) > 0 {
		for _, e := range m.Deletes {
			l = e.Size()
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if m.TTLMinutes != 0 {
		n += 1 + sovTagging(uint64(m.TTLMinutes))
	}
	l = m.Sender.Size()
	n += 1 + l + sovTagging(uint64(l))
	return n
}

func (m *FlexStringCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	return n
}

func (m *TagCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	if len(m.PortRanges) > 0 {
		for _, s := range m.PortRanges {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Protocols) > 0 {
		l = 0
		for _, e := range m.Protocols {
			l += sovTagging(uint64(e))
		}
		n += 1 + sovTagging(uint64(l)) + l
	}
	if len(m.ASNRanges) > 0 {
		for _, s := range m.ASNRanges {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.VLanRanges) > 0 {
		for _, s := range m.VLanRanges {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.LastHopASNNames) > 0 {
		for _, s := range m.LastHopASNNames {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.NextHopASNRanges) > 0 {
		for _, s := range m.NextHopASNRanges {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.NextHopASNNames) > 0 {
		for _, s := range m.NextHopASNNames {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.BGPASPaths) > 0 {
		for _, s := range m.BGPASPaths {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.BGPCommunities) > 0 {
		for _, s := range m.BGPCommunities {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if m.TCPFlags != 0 {
		n += 1 + sovTagging(uint64(m.TCPFlags))
	}
	if len(m.IPAddresses) > 0 {
		for _, s := range m.IPAddresses {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.MACAddresses) > 0 {
		for _, s := range m.MACAddresses {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.CountryCodes) > 0 {
		for _, s := range m.CountryCodes {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.SiteNameRegexes) > 0 {
		for _, s := range m.SiteNameRegexes {
			l = len(s)
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	if len(m.DeviceTypeRegexes) > 0 {
		for _, s := range m.DeviceTypeRegexes {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.InterfaceNameRegexes) > 0 {
		for _, s := range m.InterfaceNameRegexes {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.DeviceNameRegexes) > 0 {
		for _, s := range m.DeviceNameRegexes {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.NextHopIPAddresses) > 0 {
		for _, s := range m.NextHopIPAddresses {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str00) > 0 {
		for _, e := range m.Str00 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str01) > 0 {
		for _, e := range m.Str01 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str02) > 0 {
		for _, e := range m.Str02 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str03) > 0 {
		for _, e := range m.Str03 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str04) > 0 {
		for _, e := range m.Str04 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str05) > 0 {
		for _, e := range m.Str05 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str06) > 0 {
		for _, e := range m.Str06 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str07) > 0 {
		for _, e := range m.Str07 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str08) > 0 {
		for _, e := range m.Str08 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str09) > 0 {
		for _, e := range m.Str09 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str10) > 0 {
		for _, e := range m.Str10 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str11) > 0 {
		for _, e := range m.Str11 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str12) > 0 {
		for _, e := range m.Str12 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str13) > 0 {
		for _, e := range m.Str13 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str14) > 0 {
		for _, e := range m.Str14 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str15) > 0 {
		for _, e := range m.Str15 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Str16) > 0 {
		for _, e := range m.Str16 {
			l = e.Size()
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int6400) > 0 {
		for _, s := range m.Int6400 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int6401) > 0 {
		for _, s := range m.Int6401 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int6402) > 0 {
		for _, s := range m.Int6402 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int6403) > 0 {
		for _, s := range m.Int6403 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int6404) > 0 {
		for _, s := range m.Int6404 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.AppProtocol) > 0 {
		for _, s := range m.AppProtocol {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int00) > 0 {
		for _, s := range m.Int00 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int01) > 0 {
		for _, s := range m.Int01 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int02) > 0 {
		for _, s := range m.Int02 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int03) > 0 {
		for _, s := range m.Int03 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int04) > 0 {
		for _, s := range m.Int04 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Int05) > 0 {
		for _, s := range m.Int05 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Inet00) > 0 {
		for _, s := range m.Inet00 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Inet01) > 0 {
		for _, s := range m.Inet01 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Inet02) > 0 {
		for _, s := range m.Inet02 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Inet03) > 0 {
		for _, s := range m.Inet03 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	if len(m.Inet04) > 0 {
		for _, s := range m.Inet04 {
			l = len(s)
			n += 2 + l + sovTagging(uint64(l))
		}
	}
	return n
}

func (m *TagUpsert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	if len(m.Criteria) > 0 {
		for _, e := range m.Criteria {
			l = e.Size()
			n += 1 + l + sovTagging(uint64(l))
		}
	}
	return n
}

func (m *TagDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	return n
}

func (m *ASNRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovTagging(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTagging(uint64(m.End))
	}
	return n
}

func (m *VLanRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovTagging(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTagging(uint64(m.End))
	}
	return n
}

func (m *PortRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovTagging(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTagging(uint64(m.End))
	}
	return n
}

func (m *FlexUint32Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovTagging(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTagging(uint64(m.End))
	}
	return n
}

func (m *FlexUint64Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovTagging(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTagging(uint64(m.End))
	}
	return n
}

func (m *APIServerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GUID)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTagging(uint64(l))
	}
	return n
}

func sovTagging(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTagging(x uint64) (n int) {
	return sovTagging(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TagBatchPartSender) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagBatchPartSender{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`ServiceInstance:` + fmt.Sprintf("%v", this.ServiceInstance) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagBatchPart) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUpserts := "[]TagUpsert{"
	for _, f := range this.Upserts {
		repeatedStringForUpserts += strings.Replace(strings.Replace(f.String(), "TagUpsert", "TagUpsert", 1), `&`, ``, 1) + ","
	}
	repeatedStringForUpserts += "}"
	repeatedStringForDeletes := "[]TagDelete{"
	for _, f := range this.Deletes {
		repeatedStringForDeletes += strings.Replace(strings.Replace(f.String(), "TagDelete", "TagDelete", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDeletes += "}"
	s := strings.Join([]string{`&TagBatchPart{`,
		`BatchGUID:` + fmt.Sprintf("%v", this.BatchGUID) + `,`,
		`ReplaceAll:` + fmt.Sprintf("%v", this.ReplaceAll) + `,`,
		`IsComplete:` + fmt.Sprintf("%v", this.IsComplete) + `,`,
		`Upserts:` + repeatedStringForUpserts + `,`,
		`Deletes:` + repeatedStringForDeletes + `,`,
		`TTLMinutes:` + fmt.Sprintf("%v", this.TTLMinutes) + `,`,
		`Sender:` + strings.Replace(strings.Replace(this.Sender.String(), "TagBatchPartSender", "TagBatchPartSender", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlexStringCriteria) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlexStringCriteria{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagCriteria) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStr00 := "[]FlexStringCriteria{"
	for _, f := range this.Str00 {
		repeatedStringForStr00 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr00 += "}"
	repeatedStringForStr01 := "[]FlexStringCriteria{"
	for _, f := range this.Str01 {
		repeatedStringForStr01 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr01 += "}"
	repeatedStringForStr02 := "[]FlexStringCriteria{"
	for _, f := range this.Str02 {
		repeatedStringForStr02 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr02 += "}"
	repeatedStringForStr03 := "[]FlexStringCriteria{"
	for _, f := range this.Str03 {
		repeatedStringForStr03 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr03 += "}"
	repeatedStringForStr04 := "[]FlexStringCriteria{"
	for _, f := range this.Str04 {
		repeatedStringForStr04 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr04 += "}"
	repeatedStringForStr05 := "[]FlexStringCriteria{"
	for _, f := range this.Str05 {
		repeatedStringForStr05 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr05 += "}"
	repeatedStringForStr06 := "[]FlexStringCriteria{"
	for _, f := range this.Str06 {
		repeatedStringForStr06 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr06 += "}"
	repeatedStringForStr07 := "[]FlexStringCriteria{"
	for _, f := range this.Str07 {
		repeatedStringForStr07 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr07 += "}"
	repeatedStringForStr08 := "[]FlexStringCriteria{"
	for _, f := range this.Str08 {
		repeatedStringForStr08 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr08 += "}"
	repeatedStringForStr09 := "[]FlexStringCriteria{"
	for _, f := range this.Str09 {
		repeatedStringForStr09 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr09 += "}"
	repeatedStringForStr10 := "[]FlexStringCriteria{"
	for _, f := range this.Str10 {
		repeatedStringForStr10 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr10 += "}"
	repeatedStringForStr11 := "[]FlexStringCriteria{"
	for _, f := range this.Str11 {
		repeatedStringForStr11 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr11 += "}"
	repeatedStringForStr12 := "[]FlexStringCriteria{"
	for _, f := range this.Str12 {
		repeatedStringForStr12 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr12 += "}"
	repeatedStringForStr13 := "[]FlexStringCriteria{"
	for _, f := range this.Str13 {
		repeatedStringForStr13 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr13 += "}"
	repeatedStringForStr14 := "[]FlexStringCriteria{"
	for _, f := range this.Str14 {
		repeatedStringForStr14 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr14 += "}"
	repeatedStringForStr15 := "[]FlexStringCriteria{"
	for _, f := range this.Str15 {
		repeatedStringForStr15 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr15 += "}"
	repeatedStringForStr16 := "[]FlexStringCriteria{"
	for _, f := range this.Str16 {
		repeatedStringForStr16 += strings.Replace(strings.Replace(f.String(), "FlexStringCriteria", "FlexStringCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForStr16 += "}"
	s := strings.Join([]string{`&TagCriteria{`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`Protocols:` + fmt.Sprintf("%v", this.Protocols) + `,`,
		`ASNRanges:` + fmt.Sprintf("%v", this.ASNRanges) + `,`,
		`VLanRanges:` + fmt.Sprintf("%v", this.VLanRanges) + `,`,
		`LastHopASNNames:` + fmt.Sprintf("%v", this.LastHopASNNames) + `,`,
		`NextHopASNRanges:` + fmt.Sprintf("%v", this.NextHopASNRanges) + `,`,
		`NextHopASNNames:` + fmt.Sprintf("%v", this.NextHopASNNames) + `,`,
		`BGPASPaths:` + fmt.Sprintf("%v", this.BGPASPaths) + `,`,
		`BGPCommunities:` + fmt.Sprintf("%v", this.BGPCommunities) + `,`,
		`TCPFlags:` + fmt.Sprintf("%v", this.TCPFlags) + `,`,
		`IPAddresses:` + fmt.Sprintf("%v", this.IPAddresses) + `,`,
		`MACAddresses:` + fmt.Sprintf("%v", this.MACAddresses) + `,`,
		`CountryCodes:` + fmt.Sprintf("%v", this.CountryCodes) + `,`,
		`SiteNameRegexes:` + fmt.Sprintf("%v", this.SiteNameRegexes) + `,`,
		`DeviceTypeRegexes:` + fmt.Sprintf("%v", this.DeviceTypeRegexes) + `,`,
		`InterfaceNameRegexes:` + fmt.Sprintf("%v", this.InterfaceNameRegexes) + `,`,
		`DeviceNameRegexes:` + fmt.Sprintf("%v", this.DeviceNameRegexes) + `,`,
		`NextHopIPAddresses:` + fmt.Sprintf("%v", this.NextHopIPAddresses) + `,`,
		`Str00:` + repeatedStringForStr00 + `,`,
		`Str01:` + repeatedStringForStr01 + `,`,
		`Str02:` + repeatedStringForStr02 + `,`,
		`Str03:` + repeatedStringForStr03 + `,`,
		`Str04:` + repeatedStringForStr04 + `,`,
		`Str05:` + repeatedStringForStr05 + `,`,
		`Str06:` + repeatedStringForStr06 + `,`,
		`Str07:` + repeatedStringForStr07 + `,`,
		`Str08:` + repeatedStringForStr08 + `,`,
		`Str09:` + repeatedStringForStr09 + `,`,
		`Str10:` + repeatedStringForStr10 + `,`,
		`Str11:` + repeatedStringForStr11 + `,`,
		`Str12:` + repeatedStringForStr12 + `,`,
		`Str13:` + repeatedStringForStr13 + `,`,
		`Str14:` + repeatedStringForStr14 + `,`,
		`Str15:` + repeatedStringForStr15 + `,`,
		`Str16:` + repeatedStringForStr16 + `,`,
		`Int6400:` + fmt.Sprintf("%v", this.Int6400) + `,`,
		`Int6401:` + fmt.Sprintf("%v", this.Int6401) + `,`,
		`Int6402:` + fmt.Sprintf("%v", this.Int6402) + `,`,
		`Int6403:` + fmt.Sprintf("%v", this.Int6403) + `,`,
		`Int6404:` + fmt.Sprintf("%v", this.Int6404) + `,`,
		`AppProtocol:` + fmt.Sprintf("%v", this.AppProtocol) + `,`,
		`Int00:` + fmt.Sprintf("%v", this.Int00) + `,`,
		`Int01:` + fmt.Sprintf("%v", this.Int01) + `,`,
		`Int02:` + fmt.Sprintf("%v", this.Int02) + `,`,
		`Int03:` + fmt.Sprintf("%v", this.Int03) + `,`,
		`Int04:` + fmt.Sprintf("%v", this.Int04) + `,`,
		`Int05:` + fmt.Sprintf("%v", this.Int05) + `,`,
		`Inet00:` + fmt.Sprintf("%v", this.Inet00) + `,`,
		`Inet01:` + fmt.Sprintf("%v", this.Inet01) + `,`,
		`Inet02:` + fmt.Sprintf("%v", this.Inet02) + `,`,
		`Inet03:` + fmt.Sprintf("%v", this.Inet03) + `,`,
		`Inet04:` + fmt.Sprintf("%v", this.Inet04) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagUpsert) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCriteria := "[]TagCriteria{"
	for _, f := range this.Criteria {
		repeatedStringForCriteria += strings.Replace(strings.Replace(f.String(), "TagCriteria", "TagCriteria", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCriteria += "}"
	s := strings.Join([]string{`&TagUpsert{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Criteria:` + repeatedStringForCriteria + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagDelete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagDelete{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ASNRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ASNRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VLanRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VLanRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlexUint32Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlexUint32Range{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlexUint64Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlexUint64Range{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APIServerResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&APIServerResponse{`,
		`GUID:` + fmt.Sprintf("%v", this.GUID) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTagging(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TagBatchPartSender) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagBatchPartSender: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagBatchPartSender: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagBatchPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagBatchPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagBatchPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchGUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchGUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplaceAll = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComplete = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upserts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upserts = append(m.Upserts, TagUpsert{})
			if err := m.Upserts[len(m.Upserts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deletes = append(m.Deletes, TagDelete{})
			if err := m.Deletes[len(m.Deletes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLMinutes", wireType)
			}
			m.TTLMinutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLMinutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlexStringCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlexStringCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlexStringCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = append(m.PortRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTagging
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Protocols = append(m.Protocols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTagging
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTagging
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTagging
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Protocols) == 0 {
					m.Protocols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTagging
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Protocols = append(m.Protocols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocols", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASNRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ASNRanges = append(m.ASNRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLanRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VLanRanges = append(m.VLanRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHopASNNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastHopASNNames = append(m.LastHopASNNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopASNRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopASNRanges = append(m.NextHopASNRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopASNNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopASNNames = append(m.NextHopASNNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPASPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BGPASPaths = append(m.BGPASPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPCommunities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BGPCommunities = append(m.BGPCommunities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPFlags", wireType)
			}
			m.TCPFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddresses = append(m.IPAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddresses = append(m.MACAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCodes = append(m.CountryCodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteNameRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteNameRegexes = append(m.SiteNameRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTypeRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceTypeRegexes = append(m.DeviceTypeRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceNameRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceNameRegexes = append(m.InterfaceNameRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceNameRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceNameRegexes = append(m.DeviceNameRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopIPAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopIPAddresses = append(m.NextHopIPAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str00", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str00 = append(m.Str00, FlexStringCriteria{})
			if err := m.Str00[len(m.Str00)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str01", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str01 = append(m.Str01, FlexStringCriteria{})
			if err := m.Str01[len(m.Str01)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str02", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str02 = append(m.Str02, FlexStringCriteria{})
			if err := m.Str02[len(m.Str02)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str03", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str03 = append(m.Str03, FlexStringCriteria{})
			if err := m.Str03[len(m.Str03)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str04", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str04 = append(m.Str04, FlexStringCriteria{})
			if err := m.Str04[len(m.Str04)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str05", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str05 = append(m.Str05, FlexStringCriteria{})
			if err := m.Str05[len(m.Str05)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str06", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str06 = append(m.Str06, FlexStringCriteria{})
			if err := m.Str06[len(m.Str06)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str07", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str07 = append(m.Str07, FlexStringCriteria{})
			if err := m.Str07[len(m.Str07)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str08", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str08 = append(m.Str08, FlexStringCriteria{})
			if err := m.Str08[len(m.Str08)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str09", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str09 = append(m.Str09, FlexStringCriteria{})
			if err := m.Str09[len(m.Str09)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str10", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str10 = append(m.Str10, FlexStringCriteria{})
			if err := m.Str10[len(m.Str10)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str11", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str11 = append(m.Str11, FlexStringCriteria{})
			if err := m.Str11[len(m.Str11)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str12", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str12 = append(m.Str12, FlexStringCriteria{})
			if err := m.Str12[len(m.Str12)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str13", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str13 = append(m.Str13, FlexStringCriteria{})
			if err := m.Str13[len(m.Str13)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str14", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str14 = append(m.Str14, FlexStringCriteria{})
			if err := m.Str14[len(m.Str14)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str15", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str15 = append(m.Str15, FlexStringCriteria{})
			if err := m.Str15[len(m.Str15)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str16", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str16 = append(m.Str16, FlexStringCriteria{})
			if err := m.Str16[len(m.Str16)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int6400", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int6400 = append(m.Int6400, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int6401", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int6401 = append(m.Int6401, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int6402", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int6402 = append(m.Int6402, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int6403", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int6403 = append(m.Int6403, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int6404", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int6404 = append(m.Int6404, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppProtocol = append(m.AppProtocol, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int00", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int00 = append(m.Int00, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int01", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int01 = append(m.Int01, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int02", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int02 = append(m.Int02, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int03", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int03 = append(m.Int03, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int04", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int04 = append(m.Int04, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int05", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int05 = append(m.Int05, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet00", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet00 = append(m.Inet00, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet01", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet01 = append(m.Inet01, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet02", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet02 = append(m.Inet02, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet03", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet03 = append(m.Inet03, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inet04", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inet04 = append(m.Inet04, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagUpsert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagUpsert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagUpsert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Criteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Criteria = append(m.Criteria, TagCriteria{})
			if err := m.Criteria[len(m.Criteria)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ASNRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ASNRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ASNRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLanRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLanRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLanRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlexUint32Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlexUint32Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlexUint32Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlexUint64Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlexUint64Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlexUint64Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APIServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APIServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APIServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTagging
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTagging
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTagging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTagging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTagging(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTagging
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTagging
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTagging
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTagging
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTagging
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTagging        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTagging          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTagging = fmt.Errorf("proto: unexpected end of group")
)
